Using The Dojo Toolkit (AMD-style) with TypeScript 0.9
======================================================


I. Prepare Dojo baseUrl and bootstrap
-------------------------------------

In your main HTML file, your Dojo script tag should look like this:

	<script type="text/javascript"
		data-dojo-config="async:true, baseUrl:location.href.substring(0,location.href.lastIndexOf('/')+1)+'path/to/scripts/xyz.js'"
		src="http://ajax.googleapis.com/ajax/libs/dojo/1.9.0/dojo/dojo.js">
	</script>
	
The "baseUrl" setting in DojoConfig creates a path to a script file in
your main scripts directory relative to the HTML file's location.  It
overrides the default path for loading AMD modules (other than modules
under dojo, dijit and dojox) by the Dojo AMD loader.

JavaScript files compiled from TypeScript source modules in your project
look exactly like a regular Dojo AMD-style module and are loaded
automatically when "required".

If you stay completely within TypeScript and Visual Studio, you'll find
that every TypeScript file is compiled into an AMD module (see "TypeScript
setup" below) and there is no way to automatically load the top-most one
(your root module).

The way to "bootstrap" the entire tree of modules is either: (1) write a
simple, vanilla JavaScript script that contains the "require" statement,
or (2) put that "require" statement in a script tag inside your HTML
file. Option (1) is suitable where many pages must load the same scripts.
Option (2) is simpler and suitable for one-page web apps because you
avoid creating yet another JavaScript script file.

Option (1):

	bootstrap.js:  require(["main"]);
	main.html:     <script type="text/javascript" src="bootstrap.js"></script>
	
Option (2):

	main.html:     <script type="text/javascript">require(["main"]);</script>


II. Dojo type definitions and referencing dojo.d.ts
---------------------------------------------------

Common types used in Dojo are defined in the file "dojo.types.d.ts".
You don't normally need to reference this file, since all other Dojo
definition files reference it.  You need it only if you are writing
your own module files to compile into Dojo-style modules.

Basic Dojo modules are defined in the file "dojo.d.ts".  It contains most
of the core functionalities.

To use Dojo, include the following reference in the first lines of your
TypeScript file:

	/// <reference path="dojo.d.ts"/>

To use Dijits, include the following reference in the first lines of your
TypeScript file:

	/// <reference path="dijit.d.ts"/>

To use Dijits together with Dojo:

	/// <reference path="dojo.d.ts"/>
	/// <reference path="dijit.d.ts"/>
	
Some modules are split into their own separate definition files.  For example,
to use dojo/store, you must add another refernece:

	/// <reference path="dojo.d.ts"/>
	/// <reference path="dojo.store.d.ts"/>


III. TypeScript setup
---------------------

Your TypeScript environment must be setup to compile using AMD-style
modules.  In Visual Studio, you set "Use the AMD module" to true under
Tools-Options-Web Essentials-TypeScript.

When using the command line compiler, use the "--module amd" flag.

You MUST be using TypeScript version 0.9 or higher (with generics
support).


IV. Using Dojo modules
-------------------------------------

To use a Dojo module, just "import" it:

	/// <reference path="dojo.d.ts"/>
	import array = module("dojo/_base/array");
	array.forEach(...);

compiles into:

	define(["require", "exports", "dojo/_base/array"], function(require, exports, __array__) {
		var array = __array__;
		array.forEach(...);
	});


Directly-callable Dojo modules are supported similarly.  For example:

	/// <reference path="dojo.d.ts"/>
	import ready = module("dojo/ready");
	ready(() => { ... });

compiles into:

	define(["require", "exports", "dojo/ready"], function(require, exports, __ready__) {
		var ready = __ready__;
		ready(function() { ... });
	});


Class-type Dojo modules are also supported.  For example:

	/// <reference path="dojo.store.d.ts"/>
	/// <reference path="dojo.d.ts"/>
	import Memory = require("dojo/store/Memory");
	var store = new Memory({ data: ... });

compiles into:

	define(["require", "exports", "dojo/store/Memory"], function(require, exports, __Memory__) {
		var Memory = __Memory__;
		var store = new Memory({ data: ... });
	});


V. Defining Dojo modules
------------------------

You can define modules to be used with Dojo in TypeScript.  For
example, the following:

	/// <reference path="dojo.d.ts"/>
	import array = module("dojo/_base/array");
		:
		:
	var retval = { ... };
	export = retval;

compiles to:

	define(["require", "exports", "dojo/_base/array"], function(require, exports, __array__) {
		var array = __array__;
			:
			:
		var retval = { ... };
		return retval;
	});

The "export = ..." statement is necessary because TypeScript defaults
to CommonJS-style AMD modules, which means attaching exported functions
to the "exports" object but does not return it. This will cause errors
when running the actual JavaScript with Dojo.  Perhaps in the future
TypeScript will add a feature to generate RequireJS-style AMD modules.

Using "export = ..." will also cause TypeScript to load the proper object
type for the module.


VI. Using dojo/NodeList
-----------------------

dojo/NodeList can use a number of mixin's (e.g. dojo/NodeList-dom,
dojo/NodeList-html).  After requiring these mixin's, there is no need to
explicitly use the returned type constructor, as the original
dojo/NodeList will already contain these features.  Therefore, all the
methods defined in mixin's have been added to the dojo/NodeList
definition itself.

As in the following, you can continue to use NodeList after mixing in
other NodeList features:

	/// <reference path="dojo.d.ts"/>
	import NodeList = module("dojo/NodeList");
	import NodeListDom = module("dojo/NodeList-dom");
		:
	<< you can use methods defined in dojo/NodeList-dom on NodeList >>
		:

It compiles to:

	define(["require", "exports", "dojo/NodeList", "dojo/NodeList-dom"], function(require, exports, __NodeList__, __NodeListDom__) {
		var NodeList = __NodeList__
		var NodeListDom = __NodeListDom__
			:
			:
	});

Unfortunately you cannot import a module without creating a variable
to hold it.


VII. Other TypeScript definition files
--------------------------------------

The file "dojo.d.ts" contains definitions for most of Dojo, but some
subsystems are split into separate definition files in order to
improve compilation speed and checking speed in Visual Studio.

Similarly, "dijit.d.ts" only contains base widget definitions. Other
widgets are defined in separate, grouped definition files.

When these other definitions are needed, you must put in additional
"/// <reference path="..." />" lines to pull in the relevant
definition files.

The complete list of definition files is as follows:

	dojo.types.d.ts      - Common type definitions for Dojo
	dojo.d.ts            - Dojo Core
	dojo.store.d.ts      - dojo/store modules
	dojo.data.d.ts       - Legacy dojo/data modules
	
	dijit.d.ts           - Basic widget definitions
	dijit.menu.d.ts      - dijit/Menu modules
	dijit.form.d.ts      - dijit/form base definitions
	dijit.form.button.d.ts   - dijit/form/Button
	dijit.form.textbox.d.ts  - dijit/form/TextBox


VIII. Importing plugin's
------------------------

For plugin modules, use the following undocumented feature to pull
in the dependent module at the end of the "require" list without
creating a variable:

	/// <amd-dependency path="plugin1" />
	/// <amd-dependency path="plugin2" />
	/// <amd-dependency path="plugin3" />

These must be among the first lines of the program file.


IX. dojo/text!...
-----------------

For modules like dojo/text which accepts a URL path and returns the
text of the file at that path, Dojo seems to be creating a module
with an unknown name (or at least unknown to me without reading the
Dojo source).  Therefore you won't be able to do:

	/// <amd-dependency path="dojo/text!foo/bar/baz.txt" />

	var baz = require<string>("dojo/text!foo/bar/baz.txt");      // Module not found
	
You have to fudge it like this:

	declare module "dojo/text!foo/bar/baz.txt"
	{
		var retval: string;
		export = retval;
	}

	import baz = module("dojo/text!foo/bar/baz.txt");
	
It compiles to:

	define(["require", "exports", "dojo/text!foo/bar/baz.txt"], function(require, exports, __baz__) {
		var baz = __baz__;
			:
			:
	});


X. Namespaces and types
-----------------------

Interfaces are created for most Dojo Core modules and classes for
almost all Dijit classes.  These interfaces and classes can be used
directly in TypeScript code separate from the Dojo/Dijit modules
they reside in.

Dojo namespaces and interfaces/types are proper-cased, for example:

	dojo/html        ==> Dojo.Html
	dojo/ready       ==> Dojo.Ready
	dojo/dom-class   ==> Dojo.DomClass
	
Modules under "dojo/_base" are mapped under the Dojo namespace
without the "_base" level, for example:

	dojo/_base/array ==> Dojo.Array
	dojo/_base/lang  ==> Dojo.Lang
	
Some very common Dojo classes are put under the "dojo" namespace
(notice the lower-case "d") so that they can be used directly in
TypeScript code which will compile stright to JavaScript code that
works straight out with Dojo:

	dojo.Evented
	dojo.Stateful
	dojo.Deferred
	dojo.Promise
	dojo.Animation
	
An example of using "dojo/_base/array" without using TypeScript's
"import" syntax is:

	require(["dojo/_base/array"], function(array: Dojo.Array) { ... });

Widgets defined under dijit, however, use the "dijit" namespace
(note the lower-case "d") instead of "Dijit" bacause some programmers
use them as base classes to declare new widgets -- a practice better
avoided.

TypeScript interface definitions for Dijit (i.e. not regular dijit
classes) continue to use the "Dijit" namespace.
